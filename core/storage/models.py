"""
SQLAlchemy Database Models for Zeno

Designed for Clerk authentication integration with focus on:
- Briefings and daily planning
- Complete chat history for future vector database
- Task management
- User session tracking
- Knowledge management for contextual AI
- Secure integration data storage with encryption
"""

from __future__ import annotations

import uuid
from datetime import datetime, date
from typing import Optional, Dict, Any

from sqlalchemy import (
    Column, String, Text, DateTime, Date, Boolean, Integer,
    ForeignKey, JSON, Float, Index, UniqueConstraint
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID


Base = declarative_base()


def generate_uuid():
    """Generate UUID for primary keys."""
    return str(uuid.uuid4())


class User(Base):
    """
    User model for Clerk authentication integration.
    
    Stores minimal user data since Clerk handles authentication.
    Primary key is Clerk's user_id.
    """
    __tablename__ = "users"
    
    # Clerk's user ID as primary key
    clerk_user_id = Column(String, primary_key=True)
    
    # Basic profile info (synced from Clerk via webhooks)
    email = Column(String, unique=True, nullable=False, index=True)
    first_name = Column(String)
    last_name = Column(String)
    
    # User preferences and settings
    timezone = Column(String, default="UTC")
    preferences = Column(JSON, default=dict)  # Agent persona, notification settings, etc.
    
    # Tracking
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_active_at = Column(DateTime)
    is_active = Column(Boolean, default=True)
    
    # Relationships
    sessions = relationship("UserSession", back_populates="user", cascade="all, delete-orphan")
    briefings = relationship("Briefing", back_populates="user", cascade="all, delete-orphan")
    tasks = relationship("Task", back_populates="user", cascade="all, delete-orphan")
    daily_plans = relationship("DailyPlan", back_populates="user", cascade="all, delete-orphan")
    chat_history = relationship("ChatHistory", back_populates="user", cascade="all, delete-orphan")
    documents = relationship("Document", back_populates="user", cascade="all, delete-orphan")
    integrations = relationship("Integration", back_populates="user", cascade="all, delete-orphan")
    notifications = relationship("Notification", back_populates="user", cascade="all, delete-orphan")
    knowledge_items = relationship("KnowledgeItem", back_populates="user", cascade="all, delete-orphan")


class UserSession(Base):
    """
    User session tracking for agent interactions.
    
    Tracks different agent types (MainZeno, DailyPlanning, Phone) and maintains
    conversation state for context continuity.
    """
    __tablename__ = "user_sessions"
    
    id = Column(String, primary_key=True, default=generate_uuid)
    user_id = Column(String, ForeignKey("users.clerk_user_id"), nullable=False, index=True)
    
    # Session metadata
    session_type = Column(String, nullable=False)  # "web", "phone", "api"
    agent_type = Column(String, nullable=False)    # "main_zeno", "daily_planning", "phone_telephony"
    
    # Session state and context
    conversation_state = Column(JSON, default=dict)  # Current conversation state
    agent_context = Column(JSON, default=dict)      # Agent-specific context
    shared_data = Column(JSON, default=dict)        # Data shared between agents
    
    # Timing
    started_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    last_activity_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    ended_at = Column(DateTime)
    is_active = Column(Boolean, default=True)
    
    # Relationships
    user = relationship("User", back_populates="sessions")
    chat_messages = relationship("ChatHistory", back_populates="session", cascade="all, delete-orphan")
    briefings = relationship("Briefing", back_populates="session")
    created_documents = relationship("Document", back_populates="created_by_session")
    
    __table_args__ = (
        Index("idx_user_sessions_active", "user_id", "is_active"),
        Index("idx_user_sessions_type", "user_id", "session_type"),
    )


class Briefing(Base):
    """
    Daily briefings generated by the agent.
    
    Stores morning briefings with calendar, weather, tasks, and user goals.
    """
    __tablename__ = "briefings"
    
    id = Column(String, primary_key=True, default=generate_uuid)
    user_id = Column(String, ForeignKey("users.clerk_user_id"), nullable=False, index=True)
    session_id = Column(String, ForeignKey("user_sessions.id"), nullable=True)
    
    # Briefing metadata
    briefing_date = Column(Date, nullable=False)
    briefing_type = Column(String, default="morning")  # "morning", "evening", "weekly"
    
    # Briefing content
    calendar_data = Column(JSON)      # Calendar events for the day
    weather_data = Column(JSON)       # Weather information
    task_data = Column(JSON)          # Priority tasks and due items
    email_data = Column(JSON)         # Email summary
    user_goals = Column(JSON)         # User's stated goals for the day
    
    # Generated content
    formatted_content = Column(Text)  # Voice-friendly briefing text
    summary = Column(Text)            # Brief summary
    
    # Tracking
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Relationships
    user = relationship("User", back_populates="briefings")
    session = relationship("UserSession", back_populates="briefings")
    
    __table_args__ = (
        Index("idx_briefings_user_date", "user_id", "briefing_date"),
        UniqueConstraint("user_id", "briefing_date", "briefing_type", name="uq_user_briefing_date_type"),
    )


class Task(Base):
    """
    User tasks and todos.
    
    Supports priority management, categorization, and tracking.
    """
    __tablename__ = "tasks"
    
    id = Column(String, primary_key=True, default=generate_uuid)
    user_id = Column(String, ForeignKey("users.clerk_user_id"), nullable=False, index=True)
    created_by_session_id = Column(String, ForeignKey("user_sessions.id"), nullable=True)
    
    # Task details
    title = Column(String, nullable=False)
    description = Column(Text)
    priority = Column(Integer, default=3)  # 1=highest, 5=lowest
    category = Column(String, default="general")
    status = Column(String, default="pending")  # "pending", "in_progress", "completed", "cancelled"
    
    # Scheduling
    due_date = Column(Date)
    reminder_time = Column(DateTime)
    
    # Additional metadata
    task_metadata = Column(JSON, default=dict)  # Flexible storage for future features
    tags = Column(JSON, default=list)     # For categorization and search
    
    # Tracking
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    completed_at = Column(DateTime)
    
    # Relationships
    user = relationship("User", back_populates="tasks")
    created_by_session = relationship("UserSession")
    
    __table_args__ = (
        Index("idx_tasks_user_status", "user_id", "status"),
        Index("idx_tasks_user_priority", "user_id", "priority"),
        Index("idx_tasks_due_date", "due_date"),
    )


class DailyPlan(Base):
    """
    Daily planning sessions and outcomes.
    
    Stores comprehensive daily plans created through agent interactions.
    """
    __tablename__ = "daily_plans"
    
    id = Column(String, primary_key=True, default=generate_uuid)
    user_id = Column(String, ForeignKey("users.clerk_user_id"), nullable=False, index=True)
    session_id = Column(String, ForeignKey("user_sessions.id"), nullable=True)
    
    # Plan metadata
    plan_date = Column(Date, nullable=False)
    plan_type = Column(String, default="daily")  # "daily", "weekly", "project"
    
    # Plan content
    user_goals = Column(JSON)         # Goals set by user
    planned_tasks = Column(JSON)      # Tasks planned for the day
    schedule_blocks = Column(JSON)    # Time blocks and schedule
    notes = Column(Text)              # Additional notes and reflections
    
    # Generated artifacts
    document_id = Column(String, ForeignKey("documents.id"), nullable=True)
    email_draft = Column(JSON)        # Email draft data
    
    # Tracking
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    user = relationship("User", back_populates="daily_plans")
    session = relationship("UserSession")
    document = relationship("Document")
    
    __table_args__ = (
        Index("idx_daily_plans_user_date", "user_id", "plan_date"),
        UniqueConstraint("user_id", "plan_date", "plan_type", name="uq_user_plan_date_type"),
    )


class ChatHistory(Base):
    """
    Complete conversation history for contextual AI.
    
    Stores all user interactions for building comprehensive user vault
    and future vector database implementation.
    """
    __tablename__ = "chat_history"
    
    id = Column(String, primary_key=True, default=generate_uuid)
    user_id = Column(String, ForeignKey("users.clerk_user_id"), nullable=False, index=True)
    session_id = Column(String, ForeignKey("user_sessions.id"), nullable=False, index=True)
    
    # Message details (for backward compatibility)
    message_type = Column(String, nullable=False)  # "user", "agent", "system"
    content = Column(Text, nullable=False)
    agent_type = Column(String)                    # Which agent responded

    # Context and metadata
    message_metadata = Column(JSON, default=dict)         # Tool calls, context, etc.
    context_tags = Column(JSON, default=list)     # For future vector search

    # Full conversation transcript storage
    full_transcript = Column(JSON, nullable=True)  # Complete conversation as [{"role": "user", "content": "..."}, {"role": "assistant", "content": "..."}]
    
    # Vector database preparation (for future use)
    content_vector = Column(JSON)                 # Placeholder for embeddings
    relevance_score = Column(Float)               # For ranking and retrieval
    
    # Tracking
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    
    # Relationships
    user = relationship("User", back_populates="chat_history")
    session = relationship("UserSession", back_populates="chat_messages")
    
    __table_args__ = (
        Index("idx_chat_history_user_session", "user_id", "session_id"),
        Index("idx_chat_history_user_date", "user_id", "created_at"),
        Index("idx_chat_history_message_type", "user_id", "message_type"),
    )


class Document(Base):
    """
    Documents created by the agent.
    
    Tracks Google Docs, planning documents, and other generated content.
    """
    __tablename__ = "documents"
    
    id = Column(String, primary_key=True, default=generate_uuid)
    user_id = Column(String, ForeignKey("users.clerk_user_id"), nullable=False, index=True)
    created_by_session_id = Column(String, ForeignKey("user_sessions.id"), nullable=True)
    
    # Document details
    document_type = Column(String, nullable=False)  # "daily_planning", "briefing", "task_summary"
    title = Column(String, nullable=False)
    
    # External links
    external_id = Column(String)      # Google Doc ID, etc.
    external_url = Column(String)     # Public URL
    
    # Content metadata
    content_summary = Column(Text)    # Brief summary
    content_metadata = Column(JSON, default=dict)  # Structure, sections, etc.
    tags = Column(JSON, default=list)
    
    # Tracking
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    user = relationship("User", back_populates="documents")
    created_by_session = relationship("UserSession", back_populates="created_documents")
    
    __table_args__ = (
        Index("idx_documents_user_type", "user_id", "document_type"),
    )


class Integration(Base):
    """
    External service integrations with secure encrypted storage.

    Stores OAuth tokens and configuration for Google Workspace, etc.
    Sensitive data is encrypted at rest using AES-256-GCM.
    """
    __tablename__ = "integrations"

    id = Column(String, primary_key=True, default=generate_uuid)
    user_id = Column(String, ForeignKey("users.clerk_user_id"), nullable=False, index=True)

    # Integration details
    integration_type = Column(String, nullable=False)  # "google_workspace", "weather", etc.
    provider = Column(String, nullable=False)

    # Encrypted authentication data - stored as base64-encoded encrypted JSON
    encrypted_auth_tokens = Column(Text)         # Encrypted OAuth tokens, API keys
    encrypted_config_data = Column(Text)         # Encrypted provider-specific config

    # Status
    is_active = Column(Boolean, default=True)
    token_expires_at = Column(DateTime)
    last_sync_at = Column(DateTime)

    # Tracking
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    user = relationship("User", back_populates="integrations")

    __table_args__ = (
        Index("idx_integrations_user_type", "user_id", "integration_type"),
        UniqueConstraint("user_id", "integration_type", "provider", name="uq_user_integration"),
    )

    @property
    def auth_tokens(self) -> Optional[Dict[str, Any]]:
        """Get decrypted auth tokens."""
        encrypted_data = getattr(self, 'encrypted_auth_tokens', None)
        if not encrypted_data:
            return None
        try:
            from .encryption import decrypt_integration_data
            return decrypt_integration_data(encrypted_data)
        except Exception as e:
            print(f"âŒ Failed to decrypt auth tokens for integration {self.id}: {e}")
            return None

    @auth_tokens.setter
    def auth_tokens(self, value: Optional[Dict[str, Any]]) -> None:
        """Set encrypted auth tokens."""
        print(f"ðŸ” MODEL Property setter called with value: {type(value)}")
        import traceback
        print(f"ðŸ” MODEL Call stack: {traceback.format_stack()[-3].strip()}")
        if value is None:
            self.__dict__['encrypted_auth_tokens'] = None
            self.__dict__['auth_tokens'] = None  # Clear old field too
        else:
            from .encryption import encrypt_integration_data
            encrypted = encrypt_integration_data(value)
            self.__dict__['encrypted_auth_tokens'] = encrypted
            self.__dict__['auth_tokens'] = None  # Clear old field
            print(f"âœ… MODEL Encrypted auth tokens: {len(encrypted)} chars")

    @property
    def config_data(self) -> Dict[str, Any]:
        """Get decrypted config data."""
        encrypted_data = getattr(self, 'encrypted_config_data', None)
        if not encrypted_data:
            return {}
        try:
            from .encryption import decrypt_integration_data
            return decrypt_integration_data(encrypted_data)
        except Exception as e:
            print(f"âŒ Failed to decrypt config data for integration {self.id}: {e}")
            return {}

    @config_data.setter
    def config_data(self, value: Optional[Dict[str, Any]]) -> None:
        """Set encrypted config data."""
        if value is None or value == {}:
            self.__dict__['encrypted_config_data'] = None
            self.__dict__['config_data'] = None  # Clear old field too
        else:
            from .encryption import encrypt_integration_data
            encrypted = encrypt_integration_data(value)
            self.__dict__['encrypted_config_data'] = encrypted
            self.__dict__['config_data'] = None  # Clear old field
            print(f"âœ… Encrypted config data: {len(encrypted)} chars")


class Notification(Base):
    """
    Notifications and reminders.
    
    Supports multiple delivery methods (push, email, call).
    """
    __tablename__ = "notifications"
    
    id = Column(String, primary_key=True, default=generate_uuid)
    user_id = Column(String, ForeignKey("users.clerk_user_id"), nullable=False, index=True)
    
    # Notification details
    notification_type = Column(String, nullable=False)  # "reminder", "briefing", "alert"
    title = Column(String, nullable=False)
    message = Column(Text)
    
    # Delivery
    delivery_method = Column(String, default="push")  # "push", "email", "call", "sms"
    delivery_config = Column(JSON, default=dict)      # Method-specific config
    
    # Scheduling
    scheduled_for = Column(DateTime)
    status = Column(String, default="pending")  # "pending", "sent", "failed", "cancelled"
    
    # Content
    payload = Column(JSON, default=dict)  # Rich notification data
    
    # Tracking
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    sent_at = Column(DateTime)
    
    # Relationships
    user = relationship("User", back_populates="notifications")
    
    __table_args__ = (
        Index("idx_notifications_user_status", "user_id", "status"),
        Index("idx_notifications_scheduled", "scheduled_for", "status"),
    )


class KnowledgeItem(Base):
    """
    Knowledge items for contextual AI and future vector database.
    
    Stores facts, insights, and contextual information about users
    for better personalization and recall.
    """
    __tablename__ = "knowledge_items"
    
    id = Column(String, primary_key=True, default=generate_uuid)
    user_id = Column(String, ForeignKey("users.clerk_user_id"), nullable=False, index=True)
    session_id = Column(String, ForeignKey("user_sessions.id"), nullable=True)
    
    # Knowledge content
    item_type = Column(String, nullable=False)  # "fact", "preference", "pattern", "insight"
    title = Column(String)
    content = Column(Text, nullable=False)
    
    # Context and categorization
    tags = Column(JSON, default=list)
    context_data = Column(JSON, default=dict)  # When, where, how this was learned
    
    # Vector database preparation
    content_vector = Column(JSON)              # Placeholder for embeddings
    relevance_score = Column(Float, default=1.0)
    confidence_score = Column(Float, default=1.0)
    
    # Tracking
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    last_accessed_at = Column(DateTime)
    
    # Relationships
    user = relationship("User", back_populates="knowledge_items")
    session = relationship("UserSession")
    
    __table_args__ = (
        Index("idx_knowledge_items_user_type", "user_id", "item_type"),
        Index("idx_knowledge_items_relevance", "user_id", "relevance_score"),
    )
